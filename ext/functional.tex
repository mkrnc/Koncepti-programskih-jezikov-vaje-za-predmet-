\chapter{Funkcijski programski jeziki}


\section{Matemati\v cne funkcije}



\begin{ex}
Napi\v si funkcijo v ML, ki izra\v cuna vsoto vrste: 
$$1+4+9+16+...+n^2.$$

\begin{sol}
\begin{lstlisting}
function n -> n * (n + 1) * (2*n + 1)/6
\end{lstlisting}
\end{sol}

\end{ex}



\begin{ex}
Napi\v si funkcijo v ML, ki izra\v cuna vsoto vrste 
$$\sum_{x=0}^n 1/(2^x) = 1/1+1/2+1/4+1/8+1/16+...+1/(2^n).$$

Preveri delovanje funkcije z implementacijo v Ocaml.
\begin{sol}
\begin{lstlisting}
    
let rec vsota_vrste n = match n with
| 1 -> 1.
| _ -> 1./.2.**(float_of_int n) +. (vsota_vrste (n-1))
\end{lstlisting}
\end{sol}
\end{ex}



\begin{ex}
V Ocaml napi\v si funkcijo, ki izra\v cuna n-to Fibonaccijevo \v stevilo definirano na slede\v c na\v cin:
\begin{center}
$F_n = 1$, \v ce $n\in \left\{ 0,1\right\}$, ter 
$F_n$ = $F_{n-1} + F_{n-2}$, 
\end{center}
pri \v cemer zapis $F_i$ predstavlja i-to Fibonaccijevo \v stevilo. 

Fibonaccijevo zaporedje: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...

\begin{sol}
\begin{lstlisting}
let rec fib n = match n with
| 0 -> 1
| 1 -> 1
| _ -> fib (n-2) + fib (n-1);;
\end{lstlisting}
\end{sol}
\end{ex}



\begin{ex}
Dana je OCaml funkcija naslednik (\lstinline{let naslednik n = n+1}). Z uporabo funkcije naslednik in brez uporabe artimeti\v cnih operacij naredi funkcijo \lstinline{jeVsota(a:int, b:int, c:int)}, ki preveri ali je c vsota a in b (pri \v cemer velja $a,b\geq 0$).


\begin{sol}
\begin{lstlisting}
let rec jeVsota (a, b, c) = match b with
| 0 -> if (a = c) then true
else false
| b -> jeVsota ((naslednjik a), b-1, c)
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Funkcija \lstinline{pfib: int*int -> int*int} je definirana na slede\v c na\v cin:
$$
\mathtt{pfib}(i,j)=\begin{cases}
(1,1); & i,j\le0;\\
\mathtt{pfib}(i-1,0); & j=0;\\
\mathtt{pfib}(0,j-1); & i=0;\\
\mathtt{pfib}(i-1,j-1)+\mathtt{pfib}(i-2,j-2); & else.
\end{cases}
$$
Operacija '+' je definirana nad pari na obi\v cajen na\v cin. Definiraj funkcijo \lstinline{pfib} v Ocaml.

\begin{sol}
\begin{lstlisting}
let vsota (a,b)(c,d) = (a+c, b+d)

let rec pfib (a,b) = match (a,b) with
| (i, j) when i <= 0 && j<=0 -> (1,1)
| (i, 0) -> pfib (i-1, 0)
| (0, j) -> pfib (0, j-1)
| (i, j) -> vsota (pfib (i-1, j-1)) (pfib (i-2, j-2))    
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
\emph{Ackermannova funkcija} je definirana z rekurzivnimi ena\v cbami.
\begin{align*}
A(0, n) &= n+1 \\
A(m + 1, 0) &= A(m, 1) \\ 
A(m + 1, n + 1) &= A(m, A(m + 1, n)) 
\end{align*}

Napi\v si funkcijo \lstinline{A : int -> int -> int}, ki izra\v cuna za dana parametra $m$ in $n$ vrednost zgoraj definirane rekurzivne funkcije.
\end{ex}




\begin{ex}
Dana je funkcija se\v stej : a' list -> int, ki se\v steje elemente danega seznama.

\begin{lstlisting}
# let rec sestej l = match l with
 | [] -> 0
 | a::r -> a+sestej r;; 
val sestej : int list -> int = <fun> 
# sestej [1;2;3];; 
- : int = 6 

\end{lstlisting}
Predstavi vsa stanja aktivacijskih zapisov ob klicu funkcije sestej [1;2;3].

\begin{sol}
\begin{lstlisting}
sestej [1;2;3] = 1+ sestej [2;3]
sestej [2;3] = 2+ sestej[1]
sestej[1] = 1+ sestej []
sestej[] = 0
sestej[1] = 1+ 0=1
sestej [2;3] = 2+ 1=3
sestej [1;2;3] = 1+ 3=4
\end{lstlisting}
\end{sol}
\end{ex}



\section{Seznami}


\begin{ex}
Napi\v si funkcijo sestej: \lstinline{int list -> int}, ki se\v steje elemente celo\v stevilskega seznama.

Primer: 
\begin{lstlisting}
# sestej [1;2;3;4;5];;
- : int = 15 
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec sestej sez = match sez with
| []->0
| hd::tl -> hd+(sestej tl)
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Napi\v si funkcijo \lstinline{unija : int list -> int list -> int list}, ki za dana seznama celih \v stevil vrne unijo. Pazi na duplikate!

Primer: \begin{lstlisting} 
# unija [1;2;4;7] [2;4;7;9];; 
- : int list = [1;2;4;7;9]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec najdi e = function
| [] -> false
| h::t ->if( h == e) then true else najdi e t

let rec unija l1 l2 =
match l1 with
| [] -> l2
| h::t -> if najdi h l2 then unija t l2
else unija t (h::l2)
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Napi\v si funkcijo \lstinline{zdruzi : int list -> int list -> int list}, ki sprejeme urejena seznama kot parametra in vrne urejen seznam, ki vsebuje elemente obeh vhodnih seznamov.

Primer: \begin{lstlisting}
# zdruzi [2;3;4] [5;7;9;10;13];;
- : int list = [2;3;4;5;7;9;10;13]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let zdruzi sez1 sez2 = sez1 @sez2

(* ali *)

let rec zdruzi sez1 sez2 = match (sez1, sez2) with
| ([], s) -> s
| (t, []) -> t
| (a::b, c::d) -> if a<=c then [a]@ (zdruzi b (c::d))
else [c]@(zdruzi (a::b) d)
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Napi\v si funkcijo \lstinline{zdruzi : int list -> int list -> int list}, ki zdru\v zi dva seznama v tretji seznam tako, da vzame najprej en element iz prvega seznama potem dva elementa iz drugega seznama in tako naprej dokler ne pride do konca enega izmed vhodnih seznamov. Preostanek nepraznega seznama se da na konec novega seznama.

Primer: \begin{lstlisting}
# zdruzi [1;2;3] [5;6;7;8];;
- : int list = [1;5;6;2;7;8;3]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
et rec zdruzi (sez1,sez2) = match (sez1,sez2) with
| ([],x) -> x 
| (x,[]) -> x 
| (g1::[],g2::r2) -> g1::g2::r2 
| (g1::r1,g2::[]) -> g1::g2::r1 
| (g1::r1,g2::g22::r2) -> g1::g2::g22:: zdruzi (r1,r2);;
\end{lstlisting}
\end{sol}
\end{ex}



\begin{ex}
Napi\v si funkcijo \lstinline{vecjeod : int list -> int -> int list}, ki dobi seznam in \v stevilo, vrne pa seznam, ki vsebuje samo elemente ve\v cje od podanega \v stevila.

Primer: \begin{lstlisting}
# vecjeod [2;5;26;87;2;6]  5;;
- : int list = [26;87;6] 
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec vecjeod sez n = match sez with
| []->[]
| hd::tl -> if(hd>n) then hd::(vecjeod tl n) else (vecjeod tl n)
\end{lstlisting}
\end{sol}

\end{ex}



\begin{ex}
Napi\v site funkcijo \lstinline{seznamnm : int -> int list}, ki izpi\v se seznam \v stevil od \v stevila n do m. Velja $n\le m$.

Primer: \begin{lstlisting}
# seznamnm 5 11;;
- : int list = [5;6;7;8;9;10;11] 
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec seznamnm n m =
if n > m then []
else n :: seznamnm (n+1) m;;
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Napi\v si funkcijo \lstinline{palindrom: int list -> bool}, ki preveri, \v ce je podan seznam celih \v stevil palindrom.

Primer: \begin{lstlisting}
# palindrom [1;2;3;2;1];;
- : bool = true
# palindrom [1;2;3];;
- : bool = false
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let palindrom sez =
sez = List.rev sez
\end{lstlisting}
\end{sol}

\end{ex}



\begin{ex}
Napi\v si funkcijo \lstinline{vsotaSodeLihe: int list -> int*int}, ki za dani seznam posebej se\v steje soda in liha \v stevila, ter vrne par, ki ima na prvem polo\v zaju vsoto lihih \v stevil, na drugem pa vsoto sodih \v stevil.

Primer: \begin{lstlisting}
# vsotaSodeLihe [1;1;1;2;4];;
- : int*int = (3,6)
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec vsotaSodeLihe sez = match sez with
| [] -> (0, 0)
| a::b -> let (l,s) = vsotaSodeLihe b in 
if (a mod 2 = 1) then 
(l+a, s) 
else 
(l, s+a)
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
Napi\v si funkcijo \lstinline{podseznam : int list -> int list -> bool}, ki preveri ali je seznam podan kot prvi parameter podseznam seznama podanega kot drugi parameter funkcije.

Primer: \begin{lstlisting}
# podseznam [1;2] [3;4;1;2];;
- : bool = true
# podseznam [1;2] [1;2;3];;
- : bool = true
# podseznam [1;2] [4;2];;
- : bool = false
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec podseznam sez1 sez2 = match (sez1, sez2) with
| ([], _) -> true
| (a::b, c::d) when List.length sez1 <= List.length sez2 -> if (a=c) then podseznam b d else false
| _ -> false
\end{lstlisting}
\end{sol}



\end{ex}
\begin{ex}
  Dan imamo seznam znakov tipa \lstinline{char list} v katerem se lahko
  pojavijo samo znaka \lstinline{'a'} in \lstinline{'b'}. Napi\v si funkcijo
  \lstinline{cnta : char list -> int list}, ki pretvori sekvence znakov v
  seznam celih \v stevil po naslednjih pravilih:

    -- \lstinline{aaa -> 3},
    
    -- \lstinline{aa -> 2},
    
    -- \lstinline{a -> 1} in
    
    -- \lstinline{x -> 0}, kjer je \lstinline{x} poljuben znak.

\noindent\/Primer:
\begin{lstlisting}
# cnta ['a','a','a','a','a','b','a','a'];;
- : int list = [3,2,0,2]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec cnta sez = match sez with
| [] -> []
| 'a'::'a'::'a'::r -> 3 :: cnta r 
| 'a'::'a'::r -> 2 :: cnta r 
| 'a'::r -> 1 :: cnta r 
| _::r -> 0 :: cnta r;;
\end{lstlisting}
\end{sol}
\end{ex} 



\begin{ex}
Funkcijo za sortiranje seznama implementiraj na slede\v c na\v cin:

\begin{enumerate}
\item Napi\v si pomo\v zno funkcijo zamenjaj : \lstinline{int list -> int list}, ki poi\v s\v ce v seznamu prvi zaporeden par \lstinline{...::x::y::rep}, ki ni pravilno urejen: $x>y$. Funkcija naj vrne par sestavljen iz 
	\begin{enumerate}
	\item istega seznama, kjer sta x in y zamenjana ter 
    \item true v primeru, da je bila zamenjava narejena in false sicer.
	\end{enumerate}
    \item Napisi funkcijo \lstinline{sortiraj : int list -> int list}, ki ponavlja izvajanje funkcije zamenjaj tako dolgo dokler ni seznam urejen.
\end{enumerate}
\end{ex}
\begin{ex}
Dan je seznam, ki vsebuje znake tipa char. Napi\v si funkcijo \lstinline{ace}, ki sprejme seznam znakov in vrne true v primeru, da seznam znakov vsebuje znake seznama ['a';'c';'e'] v danem vrstnem redu in false sicer. 

\begin{lstlisting}
# ace ['a';'b';'r';'a';'k';'a';'d';'a';'b';'r';'a'];;
- : bool = false
# ace ['a';'b';'e';'c';'e';'d';'a'];;
- : bool = true
# ace ['c';'e';'d';'r';'a'];;
- : bool = false
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec ace1 sez count = match sez with
| [] -> false
| a::b -> if (count = 0 && a = 'a') then ace1 b 1
else if(count = 1 && a = 'c') then ace1 b 2
else if (count = 2 && a = 'e') then true
else ace1 b count

let ace sez = ace1 sez 0
\end{lstlisting}
\end{sol}

\end{ex}



\begin{ex}
Dan je seznam, ki vsebuje vrednosti 0 in 1. Napi\v si funkcijo, ki naredi naslednjo transformacijo na seznamu. Vse pojavitve vzorca 111 zamenja z vrednostjo 3, vse pojavitve vzorca 11 z vrednostjo 2 ter ohrani samostojne enice 1 in ni\v cle 0. 
\begin{lstlisting}
1 1 1 -> 3
1 1 -> 2
1 -> 1
0 -> 0
\end{lstlisting}

Funkcija vedno posku\v sa najprej zamenjati dalj\v si niz enic.

Na primer, seznam \lstinline{[1;1;0;1;1;1;1;1;0;1;0]} se pretvori v seznam \lstinline{[2;0;3;2;0;1;0]}.

\begin{sol}
\begin{lstlisting}
let rec fja list = match list with
| [] -> []
| a::[] -> [a]
| a::b when a=0 -> a::(fja b)
| a::b::c when a=1 && b=0 ->[a; b]@(fja c)
| a::b::c when a=1 && b=1 && c=[] -> [2]@(fja c)
| a::b::c::d when a=1 && b=1 -> if c=1 then [3]@(fja d)
else [2; c]@(fja d)
\end{lstlisting}
\end{sol}
\end{ex}



\begin{ex}
  Napi\v si funkcijo cikli : int -> int -> int, ki za klic cikli m n
  generira seznam n ciklov \v stevil od 0 do m-1.

\noindent\/Primer:
\begin{lstlisting}
# cikli 3 4;; 
- : int list = [0; 1; 2; 0; 1; 2; 0; 1; 2; 0; 1; 2]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec stevila n m = let x=m-1 in
if n > x then []
else n :: stevila (n+1) m;;

let rec cikli m n = match n with
| 0 -> []
| _ -> (stevila 0 m)@cikli m (n-1)
\end{lstlisting}
\end{sol}

\end{ex} 



%----
\begin{ex}
  \label{dnk-naloga}
  Dano imamo sekvenco DNK v obliki seznama znakov tipa \lstinline{dnk list},
  kjer je tip \lstinline{dnk} definiran kot

  \begin{lstlisting}
  type dnk = A | C | T | G
  \end{lstlisting}
  Na primer, niz znakov "ACAAGT"  je predstavljen s seznamom 
  \lstinline{[A;\-C;A;A;G;T]}. 

  Napi\v si funkcijo \lstinline{najpodniz : dnk list -> int*int}, ki
  poi\v s\v ce najdalj\v si podniz istih znakov tipa \lstinline{dnk} ter
  izpi\v se pozicijo prvega znaka in dol\v zino niza.
\end{ex} 



\begin{ex}
  Dano imamo sekvenco DNK v obliki seznama znakov tipa \lstinline{dnk list},
  kjer je tip \lstinline{dnk} definiran kot v Nalogi \ref{dnk-naloga}.

  Napi\v si funkcijo \lstinline{prestej : dnk list -> dnk*int list}, ki
  se\v steje enake zaporedne znake v sekvenci in za vsako skupino
  kreira par, ki vsebuje \lstinline{dnk} znak in \v stevilo pojavitev
  znaka.

  \emph{Primer}: 
  \begin{lstlisting}
  # prestej [A;C;A;A;G;C;C];;
  val - : dnk*int list = [(A,1);(C,1);(A,2);(G,1);(C,2)]
  \end{lstlisting}
\end{ex} 



\begin{ex}
  Napi\v si funkcijo \lstinline{zamenjaj : int list -> int list}, ki v
  enem prehodu poi\v s\v ce v seznamu celih \v stevil vse zaporedne
  pare \lstinline{x::y}, ki niso urejeni po nara\v s\v cajo\v cem vrstnem
  redu (\lstinline{x<=y}) in jih obrne.

  Z uporabo funkcije \lstinline{zamenjaj} implementiraj sortiranje seznama.
\end{ex} 



\begin{ex}
  Relacijo $\mathcal{R}$ predstavimo s seznamom parov celih \v
  stevil. Napi\v si funkcijo

  \begin{lstlisting}
  razsiri : int*int list -> int list -> int list,
  \end{lstlisting}

  kjer je prvi parameter seznam parov \lstinline{r} in drugi parameter
  seznam celih \v stevil \lstinline{s}. Rezultat funkcije
  \lstinline{razsiri} naj bo seznam, ki vsebuje vsa \v stevila \lstinline{x}
  za katera velja \lstinline{(e,x)}$\in\mathcal{R}$ za nek element e
  seznama \lstinline{s}.
\end{ex} 



\begin{ex}
  Napi\v si funkcijo

  \begin{lstlisting}
  zdruzi : int list -> int list -> int list,
\end{lstlisting}

  ki zdru\v zi urejena seznama celih \v stevil tako, da je rezultat
  urejen in hkrati izlo\v ci ve\v ckratne ponovite elementov.

  \begin{sol}
  \begin{lstlisting}
  let rec zdruzi list1 list2 = match (list1, list2) with
  | ([], []) -> []
  | (a, []) -> a
  | ([], b) -> b
  | (a::b, c::d) -> 
       if (a < c ) then a::(zdruzi b (c::d))
       else if (c<a) then c::(zdruzi (a::b) d)
            else a::(zdruzi b d)
  \end{lstlisting}
  \end{sol}
\end{ex} 



\begin{ex}
  Dana je funkcija \lstinline{fib3}, ki je definirana na slede\v c na\v cin:
\begin{lstlisting}
  fib3(n) = 1, za n=1,2,3
  fib3(n) = fib3(n-1)+fib3(n-2)+fib3(n-3), za n>3.
\end{lstlisting}

  Napi\v si funkcijo 
  \lstinline{fib3list : int -> int list}, ki generira seznam
  vrednosti funkcije fib3 od $1$ do $n$, kjer je $n>0$ parameter funkcije.

\noindent\/Primer:
\begin{lstlisting}
# fib3 6;;
_ : int list = [1; 1; 1; 3; 5; 9]
\end{lstlisting}

%\begin{sol}
%\begin{lstlisting}
%let rec fib3 x = match x with
%| 0 -> []
%| _ -> match fib3(x-1) with
%| [] -> [1]
%|	[_] -> [1;1]
%| [;] -> [1;1;1]
%|	a::b::c::_ as smallfib -> (a+b+c)::smallfib;;
%
%let rec obrni sez = match sez with
%| [] -> []
%| g::r -> (obrni r)@[g];;
%
%obrni (fib3 6);;
%
%note: not optimal. feel free to edit. I'm not planing on doing HM with this
%\end{lstlisting}
%\end{sol}
\end{ex} 



\begin{ex}
Napi\v si funkcijo v Ocaml, ki za dani seznam celih \v stevil se\v steje soda in liha \v stevila, ter vrne par, ki ima na prvem mestu vsoto lihih \v stevil, na drugem pa vsoto sodih \v stevil.

\end{ex} 



\begin{ex}
  Seznam tipa (string*string) list predstavlja lete neke letalske
  dru\v zbe. Vsak par opi\v se direkten let med dvemi mesti. Napi\v si
  funkcijo

\begin{lstlisting}
povezava : (string*string) -> (string*string) list -> bool,
\end{lstlisting}

  ki preveri ali obstaja povezava med dvemi mesti podanimi s prvim
  parametrom. Povezava je lahko direktna ali z enim vmesnim
  postankom. Seznam letov letalske dru\v zbe je podan z drugim
  parametrom. Funkcija vrne true v primeru, da povezava obstaja in
  false sicer.

  Dodatne to\v cke: Naj povezava pomeni poljubno povezavo, ki je
  sestavljena iz poljubnega \v stevila vmesnih postankov.
\end{ex} 



\begin{ex}Naloga je sestavljena iz dveh delov.

  a) Definiraj tip plist, ki predstavi seznam parov. Prva komponenta
  para vsebuje klju\v ce tipa int in druga komponenta vrednosti tipa
  string.

  b) Napi\v si funkcijo  
\begin{lstlisting}
vapply : plist -> (string -> string) -> plist,
\end{lstlisting}
  ki aplicira funkcijo tipa \lstinline{string -> string} (drugi parameter) na vseh
  drugih komponentah parov, ki so podani s prvim parametrom
  funkcije. 

  Rezultat naj bo seznam parov kjer je druga komponenta vhodnih parov
  zamenjana z vrednostjo funkcije 
  \lstinline{string -> string}.
\end{ex} 




\section{Polimorfizem}



\begin{ex}
Napi\v si polimorfi\v cno funkcijo 

\begin{center}
\lstinline{zdruzi : 'a list -> 'a list -> ('a*'a->'a) -> 'a list}, 
\end{center}

ki zdruzi dva enako dolga seznama poljubnih objektov, tako da zdru\v zi istole\v zne objekte seznamov. Par istole\v znih objektov seznamov zdru\v zimo z uporabo tretjega parametra funkcije zdruzi, funkcijo tipa \lstinline{'a*'a->'a}.

Napi\v si primer uporabe funkcije zdruzi nad seznamoma celih \v stevil. Zdru\v zitev dveh \v stevil implementiraj z obi\v cajno vsoto. 
\end{ex}



\begin{ex}
  Napi\v si polimorfi\v cno funkcijo
  \begin{lstlisting}
  ostevilci : 'a list -> (int * 'a) list, 
  \end{lstlisting}
  ki o\v stevil\v ci elemente od $1$ do $n$, \v ce je n dol\v zina
  vhodnega seznama. Funkcija ostevilci naj vrne seznam parov, kjer je
  prva komponenta indeks in druga komponenta orginalna vrednost iz
  seznama.
\end{ex} 



\begin{ex}
Tip ('a*'b) list opisuje seznam parov kjer je prva komponenta klju\v c tipa 'a in druga komponenta vrednost tipa 'b. 

Napi\v si funkcijo 

meet : ('a*'b) list -> ('a*'b) list -> ('a*('b*'b)) list,

ki zdru\v zi dva seznama sortirana po klju\v cu tipa 'a. Pari iz vhodnih seznamov se zdru\v zijo samo v primeru, da se ujemajo v klju\v cu. Rezultat funkcije so pari sestavljeni iz klju\v ca in vrednosti, ki vsebuje obe vrednosti iz vhodnih parov.  

Primer:    
\begin{lstlisting}
meet [(1,2);(2,3);(4,5);(4,9)] [(2,4);(4,6)] -> 
     [(2,(3,4));(4,(5,6));(4,(9,6))]
\end{lstlisting}
\end{ex} 



\begin{ex}
  Tip ('a*'b) list opisuje seznam parov, kjer je prva komponenta para
  klju\v c tipa 'a in druga komponenta vrednost tipa 'b.

  Predpostavimo, da so vhodni seznami sortirani po klju\v cu tipa
  'a. Napi\v si funkcijo

\begin{lstlisting}
diff : ('a*'b) list -> ('a*'b) list -> ('a*'b) list,
\end{lstlisting}

  ki izra\v cuna razliko dveh seznamov. Rezultat vsebuje vse pare iz
  prvega seznama s klju\v ci, ki se ne pojavijo v drugem seznamu.

\noindent\/Primer:    
\begin{lstlisting}
diff [(1,2);(2,3);(4,5)];(5,6)] [(2,4);(4,6)] -> [(1,2);(5,6)]
\end{lstlisting}



\end{ex} 
\begin{ex}
Napi\v si parametri\v cno funkcijo 
\begin{lstlisting}
podseznam : 'a list -> int*int -> 'a list, 
\end{lstlisting}
ki iz danega seznama izlu\v s\v ci podseznam dolo\v cen z drugim parametrom funkcije $(z,k)$, 
kjer $z$ predstavlja indeks za\v cetka podseznama in $k$ indeks konca podseznama. 

Predpostavimo, da je $z<k$ in $k<l$, kjer je $l$ dol\v zina vhodnega seznama. 
\end{ex} 



\begin{ex}
  Dan je seznam parov, ki vsebujejo klju\v c tipa 'k in vrednost tipa
  'v. Napi\v si funkcijo
\begin{lstlisting}
  filter ('v->bool) -> 'k*'v list -> 'k list,
\end{lstlisting}
  ki iz seznama parov dolo\v cenim z 2. parametrom izbere tiste klu\v
  ce za katere vrne funkcija \lstinline{('v->bool)} dolo\v cena s 1. parameterom
  vrednost true. Rezultat funcije filter je seznam tak\v snih klju\v
  cev.

\noindent\/Primer:
\begin{lstlisting}
# filter (function x -> x=0) [(1,0);(2,1);(3,0);(4,1)];; 
- : int list = [1; 3] 

\end{lstlisting}
\end{ex} 



\section{Funkcije vi\v sjega reda}



\begin{ex}
Napi\v si funkcijo vi\v sjega reda 
\begin{center}
\lstinline{urediPar : 'a*'a -> ('a*'a->bool) -> 'a*'a}, 
\end{center}
ki za dan par vrednosti tipa 'a*'a vrne isti par vrednosti urejen po velikosti. Za dolo\v citev vrstnega reda komponent para napi\v si funkcijo 
\lstinline{vecji : 'a*'a -> bool}, 
ki vrne \lstinline{true}, \v ce je prva komponenta ve\v cja od druge. Uporabi funkcijo ve\v cji kot parameter funkcije \lstinline{urediPar}.

\end{ex}
\begin{ex}
Napi\v si funkcijo vi\v sjega reda 
\begin{center}
\lstinline{izberi l f: 'a list -> ('a -> bool) -> 'a list},
\end{center}
ki iz seznama l izbere samo
tiste elemente a za katere funkcija f vrne true.
Primer: 
\begin{lstlisting}
# let f a = if a>2 then true else false;;
val f : int -> bool = <fun>
# izberi [1;2;3;5] f;;
- : int list = [3; 5]
\end{lstlisting}
\end{ex}



%----
\begin{ex}
  Napi\v si funkcijo vi\v sjega reda

  \begin{lstlisting}
  skrci : (int * int -> int) -> list int -> int,
  \end{lstlisting}
  katere prvi parameter \lstinline{f : int*int -> int} je funkcija, ki
  zdru\v zi dve vrednost iz seznama v en samo vrednost tipa
  \lstinline{int}. Drugi parameter \lstinline{skrci} je seznam celih \v
  stevil.

  Naj bo funkcija \lstinline{f} prvi parameter in seznam \lstinline{l = [i1; i2; ...; in] } drugi parameter. Pomen funkcije \lstinline{skrci}
  lahko zapi\v semo na naslednji na\v cin.

  \begin{lstlisting}
  skrci f l = f i1 (f i2 f(...(f in-1 in)))
  \end{lstlisting}
  Predpostavi, da ima seznam \lstinline{l} vsaj dva elementa!
\end{ex}



\begin{ex}
Napi\v si funkcijo vi\v sjega reda 

\begin{lstlisting}
foldx : 'a list -> 'b -> ('a -> 'b -> 'b) list -> 'b,
\end{lstlisting}
ki nad seznamom, ki je podan s prvim argumentom, in za\v cetno vrednostjo podano z drugim argumentom, aplicira funkcije iz seznama podanega kot tretji argument na slede\v c na\v cin. 

Naj bo prvi argument enak \lstinline{[a1,a2,...,an]},
drugi argument \lstinline{b}, in tretji argument enak
\lstinline{[f1,f2,...,fn]}. 
Rezultat dobimo na slede\v c na\v cin: 
\begin{lstlisting}
    f1 a1  (f2 a2 ... (fn  an b) ...)
\end{lstlisting}


\end{ex} 

%\section{Implementacija funkcij} <-- merged with matematicne funkcije





\section{Rekurzivni tipi}
%Rekurzivni tipi?





\begin{ex}
Dan imamo seznam, definiran z rekurzivnim podatkovnim tipom izraz. 
\begin{lstlisting}
type izraz = 
      Nil 
    | Stevilo of int * izraz 
    | Oper of char * izraz ;; 
\end{lstlisting}
Izraz vsebuje aritmeti\v cne izraze, ki so lahko sestavljeni iz \v stevil (Stevilo) in operacij (Oper). Dovoljene operacije so plus '+' in minus '-'. Predpostavljamo, da izrazi opisujejo pravilne aritmeti\v cne izraze.

Napi\v si funkcijo ovrednoti : izraz -> int, ki izra\v cuna vrednost izraza.
Primer: 
\begin{lstlisting} 
    e = 10 + 5 - 3
\end{lstlisting}

\end{ex}






\begin{ex}
  Binarno drevo je definirano s tipom
\begin{lstlisting}
type bdrevo = List of int |
            Drevo of bdrevo * int * bdrevo,
\end{lstlisting}
  ki ima vrednosti v listih definirane kot \lstinline{List v}, kjer je
  $v$ celo \v stevilo.  Notranja vozli\v s\v ca so definirana kot
  trojica \lstinline{Drevo (l, v, d)}, kjer sta $l$ in $d$ levo in desno
  poddrevo, $v$ pa je vrednost%, ki je za\v cetno $0$ za vsa notranja vozli\v s\v ca.
.
  \begin{enumerate}[label=(\roman*)]
  \item Napi\v si funkcijo \lstinline{prestej : bdrevo -> int}, 
    ki vrne vsoto vrednosti podanih v listih vhodnega drevesa.

  \item Napi\v si funkcijo
    \lstinline{oznaci : bdrevo -> bdrevo,}
    ki drugo komponento vseh notranjih vozli\v s\v c izhodnega drevesa
    zamenja z vsoto vseh listov poddrevesa.
  \end{enumerate}
\begin{sol}
Naloga (i):
\begin{lstlisting}
let rec prestej dr = match dr with
| List x -> x
| Drevo (a,b,c) -> prestej a + prestej c
\end{lstlisting}
Naloga (ii):
\begin{lstlisting}
let rec oznaci dr = match dr with
| List a -> dr 
| Drevo (d,f,g) -> Drevo (oznaci d, prestej dr ,oznaci g)
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}
  Binarno drevo je definirano s tipom itree, ki predstavlja binarno
  drevo katerega vozli\v s\v ca vsebujejo vrednost tipa int.
\begin{lstlisting}
  type itree = Nil | Node of itree*int*itree;;
\end{lstlisting}

  Napi\v si funkcijo sumsub : itree -> itree, ki iz vhodnega drevesa
  konstruira novo drevo, ki namesto originalnih vrednosti v voli\v s\v
  cih vsebuje vsoto vrednosti vozli\v s\v c levega in desnega
  pod-drevesa ter vrednosti danega vozli\v s\v ca.

\noindent\/Primer:
\begin{lstlisting}
# sumsub Node(Node(Nil,3,Nil),5,Node(Nil,2,Node(Nil,1,Nil)));;
_ : itree = Node(Node(Nil,3,Nil),11,Node(Nil,3,Node(Nil,1,Nil)))
\end{lstlisting}
\end{ex} 




\begin{ex}
Dan je tip bdrevo, ki je definiran na naslednji na\v cin

\begin{lstlisting}
type bdrevo = Leaf of int | Node of bdrevo * int * bdrevo;;
\end{lstlisting}

Napi\v si funkcijo bapply : bdrevo -> (int -> int) -> bdrevo, ki aplicira funkcijo (int -> int) na vseh vozli\v s\v cih drevesa.  
\end{ex} 





\begin{ex}
Drevo je definirano z naslednjim tipom. 

\begin{lstlisting}
type bindrevo = List of int | Drevo of bindrevo * bindrevo ;; 
\end{lstlisting}

Napi\v si funkcijo izpis : bindrevo -> int -> unit, ki izpi\v se vse liste katerih vrednost je ve\v cja od drugega parametra. 
\end{ex} 





\begin{ex}
  Drevo int\_tree je definirano na naslednji na\v cin.

\begin{lstlisting}
type int_tree = { mutable key:int; mutable trees: int_tree list}
\end{lstlisting}

  Napi\v si funkcijo vi\v sjega reda

\begin{lstlisting}
tree_filter : int_tree -> int -> int list.
\end{lstlisting}

  Funkcija vrne seznam vseh klju\v cev iz drevesa podanega s prvim
  parametrim, ki so ve\v cji od vrednosti podane z drugim parametrom
  funkcije.
\end{ex} 





\section{Parametrizirani tipi}




%sez
\begin{ex}
Dan imamo seznam, definiran z naslednjim tipom. 
\begin{lstlisting}
type 'a seznam = 
      Nil 
    | Vrednost of 'a * 'a seznam;; 
\end{lstlisting}

Seznam je urejen v nara\v s\v cajo\v cem vrstnem redu glede na vrednost primerjalne funkcije primerjaj : 'a -> 'a -> int , ki vrne -1 \v ce je prvi parameter ve\v cji od drugega, 0 \v ce sta enaka in 1 v primeru, da je drugi parameter ve\v cji od prvega.

Napi\v si parametri\v cno funkcijo:
\begin{lstlisting}
dodaj : 'a seznam -> ('a -> 'a -> int) -> 'a
\end{lstlisting}
kjer je prvi parameter seznam v katerega dodajamo, drugi parameter je funkcija primerjaj in tretji parameter vrednost tipa 'a, ki jo dodajamo v seznam.
\end{ex}




\begin{ex}
  Seznam definiramo z zapisom, ki ima dve komponenti: vrednost tipa
  \lstinline{'a} in kazalec na naslednji element seznama tipa \lstinline{'a seznam}, ki je bodisi prazen ali pa ima še vsaj en element.

  \begin{lstlisting}
  type 'a element = { 
     mutable vrednost:'a; 
     mutable naslednji:'a seznam 
  }
  and 'a seznam = Prazen | Element of 'a element ;;
  \end{lstlisting}

  Napi\v si funkcijo \lstinline{podvoji : 'a seznam -> 'a seznam}, ki
  podvoji vse vrednosti v seznamu.
\end{ex} 




\begin{ex}
  Podatkovna struktura \lstinline{seznam} je definirana na naslednji na\v
  cin.

  \begin{lstlisting}
  type 'a element = { 
     mutable vrednost: 'a; 
     mutable naslednji: 'a seznam 
  }
  and 'a seznam = Prazen | Element of 'a element ;;
  \end{lstlisting}

  Napi\v si funkcijo 
  \lstinline{zdruzi : 'a seznam -> 'a seznam -> 'a seznam}, ki ima za argumenta dva seznama tipa \lstinline{'a seznam}.

  \begin{enumerate}[label=(\roman*)]
  \item Funkcija naj zdru\v zi seznama tako, da pove\v ze konec prvega
    seznama z za\v cetkom drugega ter kot rezultat vrne za\v cetek prvega
    seznama.

  \item Funkcija naj zdru\v zi seznama tako, da naredi kopijo obeh
    seznamov v novem seznamu, ki vsebuje na novo konstruirane
    elemente.
  \end{enumerate}
\end{ex} 




%drev
\begin{ex}
  Dan je tip \lstinline{grm}, ki je definiran na slede\v c na\v cin:

\begin{lstlisting}
type 'a grm = 
    Nic 
  | Ena of 'a * 'a grm 
  | Dva of 'a grm * 'a * 'a grm;;
\end{lstlisting}

  Napi\v si funkcijo \lstinline{dolzinevej : 'a grm -> unit}, ki izpi\v
  se dol\v zine vej grma po principu levo-v-globino.
\end{ex} 




\begin{ex} 
  Podan je tip \lstinline{'a drevo} s katerim je predstavljeno binarno
  drevo.

  \begin{lstlisting}
  type 'a drevo = { 
      mutable levo:'a bin_drevo; 
      mutable vozlisce:'a; 
     mutable desno:'a bin_drevo 
  } 
  and 'a bin_drevo = Prazen | Vozlisce of 'a drevo ;;
  \end{lstlisting}

  Napi\v si funkcijo, ki izpi\v se vsa vozli\v s\v ca tretjega nivoja
  drevesa, ki obstajajo v drevesu.
\end{ex} 




\begin{ex}
Dano je drevo definirano z naslednjo podatkovno strukturo:

\begin{lstlisting}
	# type 'a tree = Empty | Node of 'a * 'a tree list ;;
\end{lstlisting}
Napi\v si funkcijo "prestej : 'a tree -> int" , ki pre\v steje vozli\v s\v ca drevesa.
\end{ex}




\begin{ex}
Dana je definicija parametri\v cnega binarnega drevesa. Parameter tipa bindrevo je spremenljivka tipa 'a, ki predstavlja tip elementov v listih drevesa.

\begin{lstlisting}
	type 'a bindrevo = List of 'a | Drevo of 'a bindrevo * 'a bindrevo ;;
\end{lstlisting}

a) Napi\v si funkcijo izpis: 'a bindrevo -> ('a -> bool) -> unit, ki zpi\v se vse liste drevesa za katere vrne drugi parameter funkcije izpis -- funkcija tipa 'a -> bool -- vrednost true. 

b) Napi\v si funkcijo obrni: 'a bindrevo -> 'a bindrevo, ki obrne vhodno drevo tako, da vsa leva poddrevesa zamenja z desnimi poddrevesi. 

\end{ex}




\begin{ex}
Dano imamo splo\v sno planarno drevo, ki je predstavljeno z naslednjim tipom:

\begin{lstlisting}
	type 'a tree = Empty 
               | Node of 'a * 'a tree list ;; 
\end{lstlisting}
Napi\v si funkcijo 
\lstinline{filter :'a tree -> ('a -> bool) -> 'a tree}, 
ki pome\v ce ven iz drevesa vsa poddrevesa s korenom za katerega vrne funkcija tipa 
\lstinline{'a -> bool},
podana kot drugi parameter, vrednost \lstinline{false}. Rezultat je torej novo drevo brez izbranih poddreves. 
\end{ex}




\begin{ex}
  Dani so tip 'a izraz, ki predstavja aritmeti\v cne izraze nad
  vrednostmi tipa \lstinline{'a}
\begin{lstlisting}
  type operacija = PLUS|MINUS;;
  type 'a izraz = 'a | 'a izraz * operacija * 'a izraz;;
\end{lstlisting}
  ter funkciji 
  \lstinline{plus :'a->'a->'a} in
  \lstinline{minus :'a->'a->'a}, 
  ki izra\v cunata vsoto in
  razliko vrednosti tipa 'a.

  Napi\v si funkcijo izracun : 'a izraz -> 'a, ki izra\v cuna vrednost
  izraza tipa 'a izraz.

\noindent\/Primer:
\begin{lstlisting}
# izracun (2,plus,(3,minus,1));;
- : int = 4
\end{lstlisting} 
\end{ex} 





%old
\begin{ex}
Napi\v si polimorfi\v cno rekurzivno funkcijo obrni: 'a array -> 'a array, ki obrne vsebino polja.

Primer: 
\begin{lstlisting}
# obrni [|1;2;3|];;
- : int array = [| 3; 2; 1 |]
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let obrni polje = let len=Array.length polje in
for i=0 to (len/2) do 
let temp = polje.(i) in
polje.(i) <- polje.(len-i-1);
polje.(len-i-1) <- temp 
done;
polje;;
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}
S poljem \v zelimo implementirati parametri\v cno podatkovno strukturo minvrsta, ki hrani zadnjih n najmanj\v sih vrednosti vstavljenih v podatkovno strukturo. Podatkovno strukturo minvrsta definiramo na slede\v c na\v cin:

\begin{lstlisting}
# type 'a minvrsta = 'a array;; 
type minvrsta = 'a array 
\end{lstlisting}
Z naslednjo funkcijo kreiramo primerek minvrsta.

\begin{lstlisting}
# let kreiraj n v = Array.create n v;;   
val kreiraj : int -> int array = <fun> 
# let a : int minvrsta = kreiraj 10 0;; 
val a : int minvrsta = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|] 
\end{lstlisting}
Napi\v si parametri\v cno funkcijo dodaj : 'a -> 'a minvrsta -> unit, ki doda novo vrednost v polje. Paziti je potrebno, da polje vedno vsebuje n najmanj\v sih vrednosti.
\end{ex}



%==============================================HERE==========================================
\begin{ex}
Dano je drevo, ki vsebuje dve vrsti elementov. Definirano je z naslednjo podatkovno strukturo:

\begin{lstlisting}
	type ('a,'b) drevo = 
     Prazno 
   | Vozliscea of 'a * ('a,'b) drevo list;;  
   | Vozlisceb of 'b * ('a,'b) drevo list;; 
\end{lstlisting}
Napi\v si funkcijo razcepi : ('a,'b) drevo -> 'a list * 'b list, ki prepi\v se vse elemente Vozliscea v prvi seznam in vse elemente Vozlisceb v drugi seznam.

\begin{sol}
\begin{lstlisting}
let razcepi drevo =
let a = ref[] in
let b = ref[] in
let rec raz dr = match dr with
| Prazno ->(!a,!b)
| Vozliscea(x,y) -> a := !a @ [x]; raz y
| Vozlisceb(x,y) -> b := !b @ [x]; raz y
in
raz drevo;;
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}
Naloga je sestavljena iz dveh delov:
\begin{enumerate}
    \item Definiraj parametri\v cno podatkovno strukturo 'a splosnoDrevo, kjer spremenljivka tipa 'a predstavlja tip vrednosti vozli\v s\v ca. Splo\v sno drevo ima poljubno \v stevilo poddreves. 
    
    \item Napi\v si funkcijo prestejOtroke : 'a splosnoDrevo -> int, ki izra\v cuna povpre\v cno \v stevilo otrok za vsa vozli\v s\v ca, ki niso listi drevesa.
\end{enumerate}

\end{ex}




%----- nekateg.
\begin{ex}
  Definiraj parametriziran tip \lstinline{'a seznam} z uporabo zapisov!
  Zapis naj ima dve komponenti: vrednost tipa \lstinline{'a} in kazalec na
  naslednji zapis v seznamu oz. prazen seznam.

  Napi\v si funkcijo \lstinline{dolzina : 'a seznam -> int}, ki
  pre\v steje \v stevilo vrednosti v seznamu.
\end{ex} 




\begin{ex}
Definiraj parametri\v cni tip \lstinline{slika}, ki predstavlja dvo dimenzionalno ra\v cunalni\v sko sliko z neznanim tipom elementov (pik) polja, ki ga ozna\v cimo z \lstinline{'a}.

Napi\v si funkcijo vi\v sjega reda

  \begin{lstlisting}
  zdruzi : 'a slika -> 'a slika -> ('a->'a->'a) -> 'a slika,
  \end{lstlisting}

ki ima prva dva parametra sliki \lstinline{s1} in \lstinline{s2} ter tretji parameter funkcijo \lstinline{f : 'a->'a->'a}, ki zdru\v zi dve piki v eno piko. Funkcija \lstinline{zdruzi} zdru\v zi istole\v zne pike iz slik \lstinline{s1} in \lstinline{s2} z uporabo funkcije \lstinline{f}.
\end{ex} 




\begin{ex}
  Dan je tip 'a struc definiran na naslednji na\v cin.
\begin{lstlisting}
  type 'a struc = 
      Elm of 'a 
    | Pair of 'a struc * 'a struc 
    | Triple of 'a struc * 'a struc * 'a struc
\end{lstlisting}
  Napi\v si polimorfi\v cno funkcijo
\begin{lstlisting}
  smap : ('a->'b) -> ('a struc) -> ('b struc),
\end{lstlisting}
  ki aplicira funkcijo f dolo\v ceno s 1. parametrom na vseh komponentah Elm x, ki so del 2. parametra. Rezultat naj bo struktura tipa 'b struc.

\noindent\/Primer:            
\begin{lstlisting}
# smap (function x -> x+1) 
       (Triple (Pair (Elm 1, Elm 2),Elm 3, Elm 4));; 
- : int struc = Triple (Pair (Elm 2, Elm 3), Elm 4, Elm 5) 
\end{lstlisting}
\end{ex} 




\begin{ex}
Dano imamo tabelo funkcij definirano z naslednjim tipom
\begin{lstlisting}
type 'a ftab = ('a->'a) array
\end{lstlisting}

Napi\v si funkcijo
\begin{lstlisting}
tapply : int*'a list -> 'a ftab -> 'a list.
\end{lstlisting}

Naj ima funkcija \lstinline{tapply l t} parameter l, ki je seznam parov oblike (i,a) in parameter t, ki je tabela funkcij. Funkcija \lstinline{tapply} pretvori l v seznam vrednosti, ki jih dobimo z aplikacijo funkcij t.(i) na a.
\end{ex} 




\begin{ex}
Definiraj parametri\v cni tip slovar, ki vsebuje seznam parov. Prvi element parov naj vsebuje klju\v c tipa int in drugi element vsebuje vrednost poljubnega tipa.

Napi\v si funkcijo 
\begin{lstlisting}
preberi : slovar -> int -> 'a, 
\end{lstlisting}
kjer 'a predstavlja tip druge komponente para v slovarju. Funkcija preberi vrne za dan klju\v c (2. parameter) iz slovarja (1. parameter) pripadajo\v co vrednost tipa 'a.
\end{ex} 




\begin{ex}
Dan je tip drevo, ki je definiran na slede\v c na\v cin:

\begin{lstlisting}
# type 'a drevo =
  List
| Veja of  'a * 'a drevo
| Rogovila of 'a drevo * 'a * 'a drevo;;
\end{lstlisting}
Napi\v si funkcijo \lstinline{dolzinevej : 'a drevo -> int list} , ki izpi\v se seznam globin listov drevesa po principu levo-v-globino. Pri tem velja, da je top vozli\v s\v ce na nivoju 0.

Primer uporabe:

\begin{lstlisting}
# dolzinevej (Rogovila (Veja (4,List),6,
              Rogovila (List,7,Veja (8,List))));;
int list = [2;2;3]
\end{lstlisting}
\end{ex} 
\begin{ex}
Definiraj parametri\v cni tip \lstinline{key\_value}, ki predstavlja zapis z dvema komponentama, prva komponenta je klju\v c tipa 'a in druga komponenta je vrednost tipa 'b. 

Na osnovi tipa \lstinline{key\_value} definiraj parametri\v cni tip slovar, ki je implementiran s poljem! 

Dano imamo polimorfi\v cno funkcijo equal : 'a -> 'a -> bool, ki vrne true v primeru, da je prvi parameter enak drugemu in false sicer. 

Napi\v si funkcijo duplikati : slovar -> slovar, ki iz slovarja odstrani vse duplikate. 
\end{ex} 



\begin{ex}
Seznam imamo definiran na nasledni na\v cin. 
\begin{lstlisting}
# type 'a rnode = { mutable cont:'a; mutable next:'a rlist } 
   and 'a rlist = Nil | Elm of 'a rnode;; 
\end{lstlisting}
Napi\v si funkcijo 
\begin{lstlisting}
p filter : 'a rlist -> ('a -> 'a -> bool) -> 'a rlist,
\end{lstlisting}
 ki vrne elemente seznama (1. parameter) za katere funkcija podana z 2. parametrom vrne vrednost true.
Funkcijo filter napi\v si tako, da ohrani\v s kopije elementov, oz. tako, da se ne kreira nov seznam!
\end{ex} 




\begin{ex}
Dano je drevo, ki vsebuje dve vrsti elementov in je definirano z naslednjo podatkovno strukturo:
\begin{lstlisting}
type ('a, 'b) tree = 
  Nil
| Nodea of 'a * ('a, 'b) tree list 
| Nodeb of 'b * ('a, 'b) tree list;; 
\end{lstlisting}
Napi\v si funkcijo 

\begin{lstlisting}
razcepi: ('a,'b) drevo -> 'a list * 'b list, 
\end{lstlisting}
ki prepi\v se vse elemente Nodea v prvi seznam, ki postane prvi element vrnjenega para, in vse elemente Nodeb v drugi seznam, ki postane drugi element vrnjenega para.
\end{ex} 




\begin{ex}
  Splo\v sno drevo 'a tree je definirano na naslednji na\v cin.

\begin{lstlisting}
type 'a tree = { mutable key:'a; mutable trees: 'a tree }
\end{lstlisting}

  Napi\v si funkcijo tree\_apply : 'a tree -> ('a -> 'b) -> 'b
  tree. Klju\v ci vozli\v s\v c vhodnega drevesa se zamenjajo z
  vrednostmi funkcije (definirane z drugim parametrom) aplicirane na
  klju\v cu vozli\v s\v ca.
\end{ex} 




\begin{ex}
  Naloga je sestavljena iz dveh delov:

\begin{itemize}
\item Definiraj parametri\v cni tip ('a,'b) key\_val, ki predstavlja
  zapis z dvema imenovanima komponentama:
  \begin{itemize}
  \item komponente key tipa 'a in
  \item komponente value tipa 'b.
  \end{itemize}
\item Napi\v si polimorfi\v cno funkcijo vi\v sjega reda

\begin{lstlisting}
array_filter : ('a,'b) key_val array -> ('a -> bool) ->  ('a,'b) key_val array
\end{lstlisting}

  ki iz polja podanega s prvim parametrom prepi\v se v kon\v cno polje
  samo tiste zapise s klju\v cem tipa 'a, za katere funkcija podana z
  drugim parametrom vrne true. \end{itemize}
\end{ex}





\section{Unije}




\begin{ex}
Dan imamo tip 

\begin{lstlisting}
	type geo_objekt = Tocka | Premica | Krog | Trikotnik 
\end{lstlisting}
in seznam geometrijskih objektov, npr.

\begin{lstlisting}
	let gl: geo_objekt list =  [ Tocka; Tocka; Premica; Krog; Krog; ... ] 
\end{lstlisting}

Napi\v si funkcijo, ki pre\v steje \v stevilo pojavitev posameznega geometrijskega objekta v seznamu:

\begin{lstlisting}
	val prestej: geo_objekt list -> 
                 geo_objekt -> int = <fun>
\end{lstlisting}

\begin{sol}
\begin{lstlisting}
let rec prestej sez geo_objekt= match sez with
| [] -> 0
| hd::tl -> if(hd = geo_objekt)then 1 + (prestej tl geo_objekt) else prestej tl geo_objekt;;
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}
Definiraj podatkovne strukture v Ocaml, ki predstavijo karte Bri\v skole ali neke druge igre s kartami, ki jo dobro pozna\v s.

\end{ex}
\begin{ex}
Seznam vrednosti in operacij je definiran s tipom formula: 
\begin{lstlisting}
# type oper = PLUS | MINUS;; 
type oper = PLUS | MINUS 
# type elm = LP | RP | Vr of int | Op of oper;; 
type elm = LP | RP | Vr of int | Op of oper 
# type formula = Nil | Form of elm * formula;; 
type formula = Nil | Form of elm * formula 
\end{lstlisting}

Napi\v si funkcijo izpis : formula -> unit, ki izpi\v se formulo. Predpostavljamo, da je formula podana v pravilni obliki.
\end{ex}




\begin{ex}
Seznam vrednosti in operacij je definiran s tipom formula: 

\begin{lstlisting}
# type oper = PLUS | MINUS;; 
type oper = PLUS | MINUS 
# type elm = Vr of int | Op of oper;; 
type elm = Vr of int | Op of oper 
# type formula = Nil | Form of elm * formula;; 
type formula = Nil | Form of elm * formula 
\end{lstlisting}

Primer: 
\begin{lstlisting}
# let s = Form(Vr(1),Form(Op(PLUS),Form(Vr(5),Form(Op(MINUS),Form(Vr(3),Nil)))));;
val s : formula = Form (Vr 1, Form (Op PLUS, Form (Vr 5, Form (Op MINUS, Form (Vr 3, Nil))))) 
\end{lstlisting}
Vrednost formule s predstavlja izraz $1+5-3$. 

Napi\v si funkcijo izracunaj : formula -> int, ki izra\v cuna vrednost seznama. Predpostavljamo, da je formula podana v pravilni obliki.
\end{ex}



\begin{ex}
Definiraj podatkovni tip \lstinline{simplKarta} s katerim predstavimo enostavne igralne karte. 
\begin{enumerate}
\item Imamo \v stiri vrste kart: kraljica, kralj, fant in punca. 
\item Karte imajo \v stiri barve: srce, kara, pik in kri\v z. 
\item Pri definiciji tipa \lstinline{simplKarta} uporabi unijo!
\end{enumerate}

Definiraj seznam kart tipa simplKarta, ki vsebuje naslednje karte: sr\v cevo punco, kri\v zevega kralja in pikovega fanta. 

\begin{sol}
\begin{lstlisting}
type vrstaKarte = Kraljica | Kralj | Fant | Punca
type barvaKarte = Srce | Kara | Pik | Kriz
type simplKarta = Vrsta of vrstaKarte*barvaKarte
let seznamKart = [(Punca,Srce);(Kralj,Kriz);(Fant,Pik)]
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}Naloga je sestavljena iz dveh delov:

a) Z uporabo unije definiraj tip 'a element, ki predstavi elemente naslednjih oblik:
\begin{lstlisting}
1. elemente tipa 'a ali
2. sezname elementov tipa 'a element.
\end{lstlisting}
    Primer elementa: 
\begin{lstlisting}
val a : int element = L [E 1; E 2; L [E 3; E 4]]
\end{lstlisting}

b) Napi\v si funkcijo print : 'a element -> unit, ki izpi\v se elemente po pravilu                          
    najprej-levo-v-globino.
\end{ex} 





\begin{ex}
   Izrazi zelo enostavnega jezika \lstinline{TP} so sestavljeni iz
   vrednosti med katerimi so postavljene operaciji \lstinline{TIMES} ali
   \lstinline{PLUS}. Obe operaciji sta levo asociativne vendar ima
   operacija \lstinline{TIMES} vi\v sjo prioriteto od
   \lstinline{PLUS}. Primer izraza je:

\begin{lstlisting}
1 PLUS 2 TIMES 3 TIMES 4,
\end{lstlisting}

   kar ustreza aritmeti\v cnem izrazu $1 + ((2 * 3) * 4)$. Izraze jezika
   TP lahko definiramo z naslednjimi tipi:
 
   \begin{lstlisting}
# type operation = PLUS | TIMES;; 
type operation = PLUS | TIMES 
# type element = Val of int | Op of operation;; 
type element = Val of int | Op of operation
# type expr = list element;;
type expr = list element
\end{lstlisting}

   \begin{enumerate}[label=(\roman*)]
   \item Napi\v si funkcijo \lstinline{check : expr -> bool}, ki preveri
     ali je izraz pravilno napisan.

   \item Napi\v si funkcijo \lstinline{calc : expr -> int}, ki izra\v
     cuna vrednost izraza.
   \end{enumerate}
\end{ex}




\begin{ex}
Izrazi enostavnega jezika z imenom TP vsebujejo cela \v stevila ter operaciji PLUS in TIMES. Predpostavimo, da imata operaciji isto prioriteto. Naslednji izraz
\begin{lstlisting}
1 PLUS 2 TIMES 3 TIMES 4,
\end{lstlisting}
ustreza aritmeti\v cnem izrazu ((1 + 2) * 3) * 4). Izrazi jezika TP so definirani z naslednjimi tipi. 
 
\begin{lstlisting}
# type operation = PLUS | TIMES;; 
type operation = PLUS | TIMES 
# type element = Val of int | Op of operation;; 
type element = Val of int | Op of operation
# type expr = list element;;
type expr = list element

\end{lstlisting}
Napi\v si funkcijo calc : expr -> int, ki izra\v cuna vrednost danega izraza.  
\end{ex} 





\begin{ex}
Boolovi izrazi so predstavljeni z naslednjim rekurzivnim tipom.   

\begin{lstlisting}
type bool_exp =
   | Val of bool
   | Not of bool_exp
   | And of bool_exp * bool_exp
   | Or of bool_exp * bool_exp;

\end{lstlisting}
Napi\v si funkcijo
\begin{lstlisting}

eval : bool_exp -> bool, 
\end{lstlisting}

ki evaluira boolov izraz v vrednost.   

Dodatna naloga: Napi\v si funkcijo, ki izpi\v se pravilnostno tabelo za dan boolov izraz.
\end{ex} 




\begin{ex}
Tip text definira predstavitev teksta v urejevalniku besedil. Primerek tipa text je sestavljen iz vrstic, ki so sestavljene iz besed.

\begin{lstlisting}
type text = Eot | Line of line * text
and line = Eol | Word of string * line
\end{lstlisting}

Napi\v si funkcijo search : text -> line -> bool, ki vrne true, \v ce je sekvenca besed definirana z drugim parametrom pod-sekvenca v tekstu, ki je podan kot prvi parameter. Predostavimo, da je iskana sekvenca vedno v eni vrstici.
\end{ex} 






